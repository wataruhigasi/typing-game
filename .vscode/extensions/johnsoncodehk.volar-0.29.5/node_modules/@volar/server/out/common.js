"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageServer = void 0;
const shared = require("@volar/shared");
const fs = require("fs");
const path = require("upath");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const vue = require("vscode-vue-languageservice");
const configs_1 = require("./configs");
const inferredCompilerOptions_1 = require("./inferredCompilerOptions");
const projects_1 = require("./projects");
const tsConfigs = require("./tsConfigs");
function createLanguageServer(connection) {
    connection.onInitialize(onInitialize);
    connection.listen();
    const documents = new vscode.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
    documents.listen(connection);
    let inited = false;
    connection.onRequest(shared.InitDoneRequest.type, async () => {
        while (!inited) {
            await shared.sleep(100);
        }
        return undefined;
    });
    connection.onRequest(shared.DepsRequest.type, () => Object.keys(require.cache));
    async function onInitialize(params) {
        var _a, _b, _c;
        const options = params.initializationOptions;
        let folders = [];
        let rootUri;
        if (((_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.workspaceFolders) && params.workspaceFolders) {
            folders = params.workspaceFolders
                .map(folder => vscode_uri_1.URI.parse(folder.uri))
                .filter(uri => uri.scheme === 'file')
                .map(uri => uri.fsPath);
        }
        else if (params.rootUri && (rootUri = vscode_uri_1.URI.parse(params.rootUri)).scheme === 'file') {
            folders = [rootUri.fsPath];
        }
        else if (params.rootPath) {
            folders = [params.rootPath];
        }
        const result = {
            capabilities: {
                textDocumentSync: vscode.TextDocumentSyncKind.Incremental,
            },
        };
        const configuration = ((_b = params.capabilities.workspace) === null || _b === void 0 ? void 0 : _b.configuration) ? connection.workspace : undefined;
        if (options.documentFeatures) {
            const ts = loadTypescript(options.typescript.serverPath);
            const formatters = await Promise.resolve().then(() => require('./formatters'));
            const noStateLs = vue.getDocumentLanguageService({ typescript: ts }, (document) => tsConfigs.getPreferences(configuration, document), (document, options) => tsConfigs.getFormatOptions(configuration, document, options), formatters.getFormatters(async (uri) => {
                var _a, _b, _c, _d, _e;
                if ((_b = (_a = options.documentFeatures) === null || _a === void 0 ? void 0 : _a.documentFormatting) === null || _b === void 0 ? void 0 : _b.getDocumentPrintWidthRequest) {
                    const response = await connection.sendRequest(shared.GetDocumentPrintWidthRequest.type, { uri });
                    if (response !== undefined) {
                        return response;
                    }
                }
                return (_e = (_d = (_c = options.documentFeatures) === null || _c === void 0 ? void 0 : _c.documentFormatting) === null || _d === void 0 ? void 0 : _d.defaultPrintWidth) !== null && _e !== void 0 ? _e : 100;
            }));
            (await Promise.resolve().then(() => require('./features/documentFeatures'))).register(connection, documents, noStateLs);
            (await Promise.resolve().then(() => require('./registers/registerDocumentFeatures'))).register(options.documentFeatures, result.capabilities);
        }
        if (options.languageFeatures) {
            let projects;
            const lsConfigs = ((_c = params.capabilities.workspace) === null || _c === void 0 ? void 0 : _c.configuration) ? (0, configs_1.createLsConfigs)(connection) : undefined;
            const ts = loadTypescript(options.typescript.serverPath);
            (await Promise.resolve().then(() => require('./features/customFeatures'))).register(connection, documents, () => projects);
            (await Promise.resolve().then(() => require('./features/languageFeatures'))).register(ts, connection, configuration, documents, () => projects, options.languageFeatures, lsConfigs, params);
            (await Promise.resolve().then(() => require('./registers/registerlanguageFeatures'))).register(options.languageFeatures, vue.getSemanticTokenLegend(), result.capabilities, ts.version);
            connection.onInitialized(async () => {
                var _a, _b;
                const inferredCompilerOptions = await (0, inferredCompilerOptions_1.getInferredCompilerOptions)(ts, configuration);
                const tsLocalized = options.typescript.localizedPath ? loadTypescriptLocalized(options.typescript.localizedPath) : undefined;
                if ((_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.didChangeConfiguration) === null || _b === void 0 ? void 0 : _b.dynamicRegistration) { // TODO
                    connection.client.register(vscode.DidChangeConfigurationNotification.type);
                }
                projects = (0, projects_1.createProjects)(folders, ts, tsLocalized, options, documents, connection, lsConfigs, inferredCompilerOptions);
                inited = true;
            });
        }
        else {
            inited = true;
        }
        return result;
    }
}
exports.createLanguageServer = createLanguageServer;
function loadTypescript(tsPath) {
    return require(path.toUnix(tsPath));
}
function loadTypescriptLocalized(tsPath) {
    if (fs.existsSync(tsPath)) {
        return require(path.toUnix(tsPath));
    }
}
//# sourceMappingURL=common.js.map