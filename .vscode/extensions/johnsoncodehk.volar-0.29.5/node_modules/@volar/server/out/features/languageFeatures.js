"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const vue = require("vscode-vue-languageservice");
const vscode = require("vscode-languageserver");
const project_1 = require("../project");
function register(ts, connection, configuration, documents, getProjects, features, lsConfigs, params) {
    connection.onCompletion(async (handler) => {
        var _a, _b, _c, _d;
        const languageService = await getLanguageService(handler.textDocument.uri);
        const list = await (languageService === null || languageService === void 0 ? void 0 : languageService.doComplete(handler.textDocument.uri, handler.position, handler.context, async () => { var _a; return (_a = await (configuration === null || configuration === void 0 ? void 0 : configuration.getConfiguration('volar.completion.autoImportComponent'))) !== null && _a !== void 0 ? _a : true; }, async (uri) => {
            var _a;
            if ((_a = features.completion) === null || _a === void 0 ? void 0 : _a.getDocumentNameCasesRequest) {
                return await connection.sendRequest(shared.GetDocumentNameCasesRequest.type, { uri });
            }
            return {
                tagNameCase: features.completion.defaultTagNameCase,
                attrNameCase: features.completion.defaultAttrNameCase,
            };
        }));
        const insertReplaceSupport = (_d = (_c = (_b = (_a = params.capabilities.textDocument) === null || _a === void 0 ? void 0 : _a.completion) === null || _b === void 0 ? void 0 : _b.completionItem) === null || _c === void 0 ? void 0 : _c.insertReplaceSupport) !== null && _d !== void 0 ? _d : false;
        if (!insertReplaceSupport && list) {
            for (const item of list.items) {
                if (item.textEdit && vscode.InsertReplaceEdit.is(item.textEdit)) {
                    item.textEdit = vscode.TextEdit.replace(item.textEdit.insert, item.textEdit.newText);
                }
            }
        }
        return list;
    });
    connection.onCompletionResolve(async (item) => {
        var _a, _b, _c;
        const uri = (_a = item.data) === null || _a === void 0 ? void 0 : _a.uri;
        if (!uri)
            return item;
        const activeSel = ((_b = features.completion) === null || _b === void 0 ? void 0 : _b.getDocumentSelectionRequest)
            ? await connection.sendRequest(shared.GetEditorSelectionRequest.type)
            : undefined;
        const newPosition = (activeSel === null || activeSel === void 0 ? void 0 : activeSel.textDocument.uri.toLowerCase()) === uri.toLowerCase() ? activeSel.position : undefined;
        const languageService = await getLanguageService(uri);
        return (_c = languageService === null || languageService === void 0 ? void 0 : languageService.doCompletionResolve(item, newPosition)) !== null && _c !== void 0 ? _c : item;
    });
    connection.onHover(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.doHover(handler.textDocument.uri, handler.position);
    });
    connection.onSignatureHelp(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.getSignatureHelp(handler.textDocument.uri, handler.position, handler.context);
    });
    connection.onPrepareRename(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.prepareRename(handler.textDocument.uri, handler.position);
    });
    connection.onRenameRequest(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.doRename(handler.textDocument.uri, handler.position, handler.newName);
    });
    connection.onCodeLens(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.getCodeLens(handler.textDocument.uri, await (lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getCodeLensConfigs()));
    });
    connection.onCodeLensResolve(async (codeLens) => {
        var _a, _b;
        const uri = (_a = codeLens.data) === null || _a === void 0 ? void 0 : _a.uri;
        const languageService = await getLanguageService(uri);
        return (_b = languageService === null || languageService === void 0 ? void 0 : languageService.doCodeLensResolve(codeLens, typeof features.codeLens === 'object' && features.codeLens.showReferencesNotification)) !== null && _b !== void 0 ? _b : codeLens;
    });
    connection.onExecuteCommand(async (handler) => {
        var _a;
        const uri = (_a = handler.arguments) === null || _a === void 0 ? void 0 : _a[0];
        const languageService = await getLanguageService(uri);
        languageService === null || languageService === void 0 ? void 0 : languageService.__internal__.executeCommand(uri, handler.command, handler.arguments, connection);
    });
    connection.onCodeAction(async (handler) => {
        const uri = handler.textDocument.uri;
        const languageService = await getLanguageService(uri);
        if (languageService) {
            const codeActions = await languageService.getCodeActions(uri, handler.range, handler.context);
            for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === 'object') {
                    codeAction.data.uri = uri;
                }
                else {
                    codeAction.data = { uri };
                }
            }
            return codeActions;
        }
    });
    connection.onCodeActionResolve(async (codeAction) => {
        var _a;
        const uri = (_a = codeAction.data) === null || _a === void 0 ? void 0 : _a.uri;
        if (uri) {
            const languageService = await getLanguageService(uri);
            if (languageService) {
                return languageService.doCodeActionResolve(codeAction);
            }
        }
        return codeAction;
    });
    connection.onReferences(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.findReferences(handler.textDocument.uri, handler.position);
    });
    connection.onDefinition(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.findDefinition(handler.textDocument.uri, handler.position);
    });
    connection.onTypeDefinition(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.findTypeDefinition(handler.textDocument.uri, handler.position);
    });
    connection.onDocumentHighlight(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.findDocumentHighlights(handler.textDocument.uri, handler.position);
    });
    connection.onDocumentLinks(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        return languageService === null || languageService === void 0 ? void 0 : languageService.findDocumentLinks(handler.textDocument.uri);
    });
    connection.onWorkspaceSymbol(async (handler, token) => {
        const projects = getProjects();
        if (projects) {
            let results = [];
            for (const workspace of projects.workspaces.values()) {
                let projects = [...workspace.projects.values()];
                projects = projects.length ? projects : [workspace.getInferredProject()];
                for (const project of projects) {
                    if (token.isCancellationRequested)
                        return;
                    const languageService = await (await project).getLanguageService();
                    results = results.concat(await languageService.findWorkspaceSymbols(handler.query));
                }
            }
            return results;
        }
    });
    connection.languages.callHierarchy.onPrepare(async (handler) => {
        const languageService = await getLanguageService(handler.textDocument.uri);
        const items = await (languageService === null || languageService === void 0 ? void 0 : languageService.callHierarchy.doPrepare(handler.textDocument.uri, handler.position));
        if (items) {
            for (const item of items) {
                if (typeof item.data !== 'object')
                    item.data = {};
                item.data.__uri = handler.textDocument.uri;
            }
        }
        return (items === null || items === void 0 ? void 0 : items.length) ? items : null;
    });
    connection.languages.callHierarchy.onIncomingCalls(async (handler) => {
        var _a, _b;
        const data = handler.item.data;
        const uri = (_a = data === null || data === void 0 ? void 0 : data.__uri) !== null && _a !== void 0 ? _a : handler.item.uri;
        const languageService = await getLanguageService(uri);
        return (_b = languageService === null || languageService === void 0 ? void 0 : languageService.callHierarchy.getIncomingCalls(handler.item)) !== null && _b !== void 0 ? _b : [];
    });
    connection.languages.callHierarchy.onOutgoingCalls(async (handler) => {
        var _a, _b;
        const data = handler.item.data;
        const uri = (_a = data === null || data === void 0 ? void 0 : data.__uri) !== null && _a !== void 0 ? _a : handler.item.uri;
        const languageService = await getLanguageService(uri);
        return (_b = languageService === null || languageService === void 0 ? void 0 : languageService.callHierarchy.getOutgoingCalls(handler.item)) !== null && _b !== void 0 ? _b : [];
    });
    connection.languages.semanticTokens.on(async (handler, token, _, resultProgress) => {
        var _a;
        const languageService = await getLanguageService(handler.textDocument.uri);
        const result = await (languageService === null || languageService === void 0 ? void 0 : languageService.getSemanticTokens(handler.textDocument.uri, undefined, token, resultProgress));
        return {
            resultId: result === null || result === void 0 ? void 0 : result.resultId,
            data: (_a = result === null || result === void 0 ? void 0 : result.data) !== null && _a !== void 0 ? _a : [],
        };
    });
    connection.languages.semanticTokens.onRange(async (handler, token, _, resultProgress) => {
        var _a;
        const languageService = await getLanguageService(handler.textDocument.uri);
        const result = await (languageService === null || languageService === void 0 ? void 0 : languageService.getSemanticTokens(handler.textDocument.uri, handler.range, token, resultProgress));
        return {
            resultId: result === null || result === void 0 ? void 0 : result.resultId,
            data: (_a = result === null || result === void 0 ? void 0 : result.data) !== null && _a !== void 0 ? _a : [],
        };
    });
    connection.workspace.onWillRenameFiles(async (handler) => {
        const hasTsFile = handler.files.some(file => file.newUri.endsWith('.vue') || file.newUri.endsWith('.ts') || file.newUri.endsWith('.tsx'));
        const config = await connection.workspace.getConfiguration(hasTsFile ? 'typescript.updateImportsOnFileMove.enabled' : 'javascript.updateImportsOnFileMove.enabled');
        if (config === 'always') {
            const renaming = new Promise(async (resolve) => {
                var _a, _b;
                for (const file of handler.files) {
                    const renameFileContent = (0, project_1.getScriptText)(documents, shared.uriToFsPath(file.oldUri), ts.sys);
                    if (renameFileContent) {
                        project_1.renameFileContentCache.set(file.oldUri, renameFileContent);
                    }
                }
                await shared.sleep(0);
                const edit = await worker();
                if (edit) {
                    if (edit.documentChanges) {
                        for (const change of edit.documentChanges) {
                            if (vscode.TextDocumentEdit.is(change)) {
                                for (const file of handler.files) {
                                    if (change.textDocument.uri === file.oldUri) {
                                        change.textDocument.uri = file.newUri;
                                        change.textDocument.version = (_b = (_a = shared.getDocumentSafely(documents, file.newUri)) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : change.textDocument.version;
                                    }
                                }
                            }
                        }
                    }
                    connection.workspace.applyEdit(edit);
                }
                resolve();
            });
            project_1.fileRenamings.add(renaming);
            (async () => {
                await renaming;
                project_1.fileRenamings.delete(renaming);
                project_1.renameFileContentCache.clear();
            })();
        }
        if (config === 'prompt')
            return await worker();
        return null;
        async function worker() {
            const edits = (await Promise.all(handler.files
                .map(async (file) => {
                const languageService = await getLanguageService(file.oldUri);
                return languageService === null || languageService === void 0 ? void 0 : languageService.getEditsForFileRename(file.oldUri, file.newUri);
            }))).filter(shared.notEmpty);
            if (edits.length) {
                const result = edits[0];
                vue.margeWorkspaceEdits(result, ...edits.slice(1));
                return result;
            }
            return null;
        }
    });
    async function getLanguageService(uri) {
        var _a;
        const projects = await getProjects();
        const project = (_a = (await (projects === null || projects === void 0 ? void 0 : projects.getProject(uri)))) === null || _a === void 0 ? void 0 : _a.project;
        return project === null || project === void 0 ? void 0 : project.getLanguageService();
    }
}
exports.register = register;
//# sourceMappingURL=languageFeatures.js.map