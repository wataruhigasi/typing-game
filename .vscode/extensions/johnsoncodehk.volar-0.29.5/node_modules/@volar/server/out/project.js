"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScriptText = exports.createProject = exports.renameFileContentCache = exports.fileRenamings = void 0;
const shared = require("@volar/shared");
const vue = require("vscode-vue-languageservice");
const vscode = require("vscode-languageserver");
const schemaRequestService_1 = require("./schemaRequestService");
const path = require("upath");
exports.fileRenamings = new Set();
exports.renameFileContentCache = new Map();
async function createProject(ts, options, rootPath, tsConfig, tsLocalized, documents, connection, lsConfigs) {
    await Promise.all([...exports.fileRenamings]);
    const projectSys = {
        ...ts.sys,
        readFile: (path, encoding) => ts.sys.readFile(resolveAbsolutePath(path), encoding),
        writeFile: (path, content) => ts.sys.writeFile(resolveAbsolutePath(path), content),
        directoryExists: path => {
            if (path === '') {
                // fix https://github.com/johnsoncodehk/volar/issues/679
                return ts.sys.directoryExists(path);
            }
            return ts.sys.directoryExists(resolveAbsolutePath(path));
        },
        getDirectories: path => ts.sys.getDirectories(resolveAbsolutePath(path)),
        readDirectory: (path, extensions, exclude, include, depth) => ts.sys.readDirectory(resolveAbsolutePath(path), extensions, exclude, include, depth),
        realpath: ts.sys.realpath ? path => {
            const resolvedPath = resolveAbsolutePath(path);
            const realPath = ts.sys.realpath(resolvedPath);
            if (realPath === resolvedPath) {
                // rollback if failed
                return path;
            }
            return realPath;
        } : undefined,
        fileExists: path => ts.sys.fileExists(resolveAbsolutePath(path)),
        getCurrentDirectory: () => rootPath,
    };
    let typeRootVersion = 0;
    let tsProjectVersion = 0;
    let vueProjectVersion = 0;
    let vueLs;
    let parsedCommandLine = createParsedCommandLine();
    const scripts = shared.createPathMap();
    const languageServiceHost = createLanguageServiceHost();
    const disposables = [];
    return {
        onWorkspaceFilesChanged,
        onDocumentUpdated,
        getLanguageService,
        getLanguageServiceDontCreate: () => vueLs,
        getParsedCommandLine: () => parsedCommandLine,
        dispose,
    };
    function resolveAbsolutePath(_path) {
        const relativePath = path.relative(ts.sys.getCurrentDirectory(), rootPath);
        if (relativePath === '')
            return _path;
        if (_path === '')
            return relativePath;
        return !path.isAbsolute(_path) ? relativePath + '/' + _path : _path;
    }
    async function getLanguageService() {
        if (!vueLs) {
            vueLs = (async () => {
                const workDoneProgress = await connection.window.createWorkDoneProgress();
                const vueLs = vue.createLanguageService({ typescript: ts }, languageServiceHost);
                vueLs.__internal__.onInitProgress(p => {
                    if (p === 0) {
                        workDoneProgress.begin(getMessageText());
                    }
                    if (p < 1) {
                        workDoneProgress.report(p * 100);
                    }
                    else {
                        workDoneProgress.done();
                    }
                });
                return vueLs;
            })();
        }
        return vueLs;
    }
    function getMessageText() {
        let messageText = options.initializationMessage;
        if (!messageText) {
            let numOfFeatures = 0;
            if (options.languageFeatures) {
                for (let feature in options.languageFeatures) {
                    if (!!options.languageFeatures[feature]) {
                        numOfFeatures++;
                    }
                }
            }
            messageText = `Initializing Vue language features (${numOfFeatures} features)`;
        }
        return messageText;
    }
    async function onWorkspaceFilesChanged(changes) {
        await Promise.all([...exports.fileRenamings]);
        for (const change of changes) {
            const script = scripts.uriGet(change.uri);
            if (script && change.type === vscode.FileChangeType.Changed) {
                if (script.version >= 0) {
                    script.version = -1;
                }
                else {
                    script.version--;
                }
            }
            else if (script && change.type === vscode.FileChangeType.Deleted) {
                scripts.uriDelete(change.uri);
            }
            updateProjectVersion(change.uri.endsWith('.vue'));
        }
        const creates = changes.filter(change => change.type === vscode.FileChangeType.Created);
        const deletes = changes.filter(change => change.type === vscode.FileChangeType.Deleted);
        if (creates.length || deletes.length) {
            parsedCommandLine = createParsedCommandLine();
            typeRootVersion++; // TODO: check changed in node_modules?
        }
    }
    async function onDocumentUpdated(document) {
        await Promise.all([...exports.fileRenamings]);
        const script = scripts.uriGet(document.uri);
        if (script) {
            script.version = document.version;
        }
        updateProjectVersion(document.uri.endsWith('.vue'));
    }
    function updateProjectVersion(isVueFile) {
        if (isVueFile) {
            vueProjectVersion++;
        }
        else {
            tsProjectVersion++;
        }
    }
    function createLanguageServiceHost() {
        var _a;
        const host = {
            // vue
            createTsLanguageService(host) {
                return shared.createTsLanguageService(ts, host);
            },
            getEmmetConfig: lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getEmmetConfiguration,
            schemaRequestService: ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.schemaRequestService) ? (0, schemaRequestService_1.getSchemaRequestService)(connection, options.languageFeatures.schemaRequestService) : undefined,
            getPreferences: lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getTsPreferences,
            getFormatOptions: lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getTsFormatOptions,
            getCssLanguageSettings: lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getCssLanguageSettings,
            // ts
            getHtmlHoverSettings: lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getHtmlHoverSettings,
            getNewLine: () => projectSys.newLine,
            useCaseSensitiveFileNames: () => projectSys.useCaseSensitiveFileNames,
            readFile: projectSys.readFile,
            writeFile: projectSys.writeFile,
            directoryExists: projectSys.directoryExists,
            getDirectories: projectSys.getDirectories,
            readDirectory: projectSys.readDirectory,
            realpath: projectSys.realpath,
            fileExists: projectSys.fileExists,
            getCurrentDirectory: projectSys.getCurrentDirectory,
            getProjectReferences: () => parsedCommandLine.projectReferences,
            // custom
            getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
            getProjectVersion: () => tsProjectVersion.toString(),
            getVueProjectVersion: () => vueProjectVersion.toString(),
            getTypeRootsVersion: () => typeRootVersion,
            getScriptFileNames: () => parsedCommandLine.fileNames,
            getCompilationSettings: () => parsedCommandLine.options,
            getVueCompilationSettings: () => { var _a, _b; return shared.resolveVueCompilerOptions((_b = (_a = parsedCommandLine.raw) === null || _a === void 0 ? void 0 : _a.vueCompilerOptions) !== null && _b !== void 0 ? _b : {}, projectSys.getCurrentDirectory()); },
            getScriptVersion,
            getScriptSnapshot,
        };
        if (tsLocalized) {
            host.getLocalizedDiagnosticMessages = () => tsLocalized;
        }
        return host;
        function getScriptVersion(fileName) {
            var _a, _b;
            return (_b = (_a = scripts.fsPathGet(fileName)) === null || _a === void 0 ? void 0 : _a.version.toString()) !== null && _b !== void 0 ? _b : '';
        }
        function getScriptSnapshot(fileName) {
            const script = scripts.fsPathGet(fileName);
            if (script && script.snapshotVersion === script.version) {
                return script.snapshot;
            }
            const text = getScriptText(documents, fileName, projectSys);
            if (text !== undefined) {
                const snapshot = ts.ScriptSnapshot.fromString(text);
                if (script) {
                    script.snapshot = snapshot;
                    script.snapshotVersion = script.version;
                }
                else {
                    scripts.fsPathSet(fileName, {
                        version: -1,
                        snapshot: snapshot,
                        snapshotVersion: -1,
                    });
                }
                return snapshot;
            }
        }
    }
    async function dispose() {
        if (vueLs) {
            (await vueLs).dispose();
        }
        for (const disposable of disposables) {
            disposable.dispose();
        }
        scripts.clear();
        disposables.length = 0;
    }
    function createParsedCommandLine() {
        const parseConfigHost = {
            useCaseSensitiveFileNames: projectSys.useCaseSensitiveFileNames,
            readDirectory: (path, extensions, exclude, include, depth) => {
                return projectSys.readDirectory(path, [...extensions, '.vue'], exclude, include, depth);
            },
            fileExists: projectSys.fileExists,
            readFile: projectSys.readFile,
        };
        if (typeof tsConfig === 'string') {
            return shared.createParsedCommandLine(ts, parseConfigHost, tsConfig);
        }
        else {
            const content = ts.parseJsonConfigFileContent({}, parseConfigHost, rootPath, tsConfig, 'tsconfig.json');
            content.options.outDir = undefined; // TODO: patching ts server broke with outDir + rootDir + composite/incremental
            content.fileNames = content.fileNames.map(shared.normalizeFileName);
            return content;
        }
    }
}
exports.createProject = createProject;
function getScriptText(documents, fileName, sys) {
    const uri = shared.fsPathToUri(fileName);
    const doc = shared.getDocumentSafely(documents, uri);
    if (doc) {
        return doc.getText();
    }
    if (sys.fileExists(fileName)) {
        return sys.readFile(fileName, 'utf8');
    }
    return exports.renameFileContentCache.get(shared.fsPathToUri(fileName));
}
exports.getScriptText = getScriptText;
//# sourceMappingURL=project.js.map