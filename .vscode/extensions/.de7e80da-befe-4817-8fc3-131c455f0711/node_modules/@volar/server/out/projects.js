"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProjects = void 0;
const shared = require("@volar/shared");
const path = require("upath");
const vscode = require("vscode-languageserver");
const project_1 = require("./project");
const rootTsConfigNames = ['tsconfig.json', 'jsconfig.json'];
function createProjects(rootPaths, ts, tsLocalized, options, documents, connection, lsConfigs, inferredCompilerOptions) {
    let semanticTokensReq = 0;
    let documentUpdatedReq = 0;
    const updatedUris = new Set();
    const workspaces = new Map();
    for (const rootPath of rootPaths) {
        workspaces.set(rootPath, createWorkspace(rootPath, ts, tsLocalized, options, documents, connection, lsConfigs, inferredCompilerOptions));
    }
    documents.onDidChangeContent(async (change) => {
        for (const workspace of workspaces.values()) {
            for (const project of workspace.projects.values()) {
                (await project).onDocumentUpdated(change.document);
            }
        }
        updateDiagnostics(change.document.uri);
    });
    documents.onDidClose(change => connection.sendDiagnostics({ uri: change.document.uri, diagnostics: [] }));
    connection.onDidChangeWatchedFiles(async (handler) => {
        const tsConfigChanges = [];
        const scriptChanges = [];
        for (const workspace of workspaces.values()) {
            for (const change of handler.changes) {
                const fileName = shared.uriToFsPath(change.uri);
                if (rootTsConfigNames.includes(path.basename(fileName)) || workspace.projects.fsPathHas(fileName)) {
                    tsConfigChanges.push(change);
                }
                else {
                    scriptChanges.push(change);
                }
            }
            if (tsConfigChanges.length) {
                clearDiagnostics();
                for (const tsConfigChange of tsConfigChanges) {
                    const tsConfig = shared.uriToFsPath(tsConfigChange.uri);
                    if (workspace.projects.fsPathHas(tsConfig)) {
                        workspace.projects.fsPathDelete(tsConfig);
                        (async () => { var _a; return (_a = (await workspace.projects.fsPathGet(tsConfig))) === null || _a === void 0 ? void 0 : _a.dispose(); })();
                    }
                    if (tsConfigChange.type !== vscode.FileChangeType.Deleted) {
                        workspace.getProjectByCreate(tsConfig); // create new project
                    }
                }
            }
            if (scriptChanges.length) {
                for (const project of workspace.projects.values()) {
                    await (await project).onWorkspaceFilesChanged(scriptChanges);
                }
            }
            onDriveFileUpdated(undefined);
        }
    });
    updateDiagnostics(undefined);
    return {
        workspaces,
        getProject,
    };
    async function onDriveFileUpdated(driveFileName) {
        var _a;
        const req = ++semanticTokensReq;
        await updateDiagnostics(driveFileName ? shared.fsPathToUri(driveFileName) : undefined);
        await shared.sleep(100);
        if (req === semanticTokensReq) {
            if ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.semanticTokens) {
                connection.languages.semanticTokens.refresh();
            }
        }
    }
    async function updateDiagnostics(docUri) {
        var _a;
        if (!((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.diagnostics))
            return;
        if (docUri) {
            updatedUris.add(docUri);
        }
        const req = ++documentUpdatedReq;
        await shared.sleep(100);
        if (req !== documentUpdatedReq)
            return;
        const changeDocs = [...updatedUris].map(uri => shared.getDocumentSafely(documents, uri)).filter(shared.notEmpty);
        const otherDocs = documents.all().filter(doc => !updatedUris.has(doc.uri));
        for (const changeDoc of changeDocs) {
            if (req !== documentUpdatedReq)
                return;
            let _isCancel = false;
            const isDocCancel = getCancelChecker(changeDoc.uri, changeDoc.version);
            const isCancel = async () => {
                const result = req !== documentUpdatedReq || await isDocCancel();
                _isCancel = result;
                return result;
            };
            await sendDocumentDiagnostics(changeDoc.uri, isCancel);
            if (!_isCancel) {
                updatedUris.delete(changeDoc.uri);
            }
        }
        for (const doc of otherDocs) {
            if (req !== documentUpdatedReq)
                return;
            const changeDoc = docUri ? shared.getDocumentSafely(documents, docUri) : undefined;
            const isDocCancel = changeDoc ? getCancelChecker(changeDoc.uri, changeDoc.version) : async () => {
                await shared.sleep(0);
                return false;
            };
            const isCancel = async () => req !== documentUpdatedReq || await isDocCancel();
            ;
            await sendDocumentDiagnostics(doc.uri, isCancel);
        }
        function getCancelChecker(uri, version) {
            let _isCancel = false;
            let lastResultAt = Date.now();
            return async () => {
                var _a;
                if (_isCancel) {
                    return true;
                }
                if (typeof ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.diagnostics) === 'object'
                    && options.languageFeatures.diagnostics.getDocumentVersionRequest
                    && Date.now() - lastResultAt >= 1 // 1ms
                ) {
                    const clientDocVersion = await connection.sendRequest(shared.GetDocumentVersionRequest.type, { uri });
                    if (clientDocVersion !== null && clientDocVersion !== undefined && version !== clientDocVersion) {
                        _isCancel = true;
                    }
                    lastResultAt = Date.now();
                }
                return _isCancel;
            };
        }
        async function sendDocumentDiagnostics(uri, isCancel) {
            var _a;
            const project = (_a = (await getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
            if (!project)
                return;
            const languageService = await project.getLanguageService();
            await languageService.doValidation(uri, async (result) => {
                connection.sendDiagnostics({ uri: uri, diagnostics: result });
            }, isCancel);
        }
    }
    async function getProject(uri) {
        var _a;
        const fileName = shared.uriToFsPath(uri);
        const rootPaths = [...workspaces.keys()]
            .filter(rootPath => shared.isFileInDir(fileName, rootPath))
            .sort(sortPaths);
        for (const rootPath of rootPaths) {
            const workspace = workspaces.get(rootPath);
            const project = await (workspace === null || workspace === void 0 ? void 0 : workspace.getProjectAndTsConfig(uri));
            if (project) {
                return project;
            }
        }
        if (rootPaths.length) {
            return {
                tsconfig: undefined,
                project: await ((_a = workspaces.get(rootPaths[0])) === null || _a === void 0 ? void 0 : _a.getInferredProject()),
            };
        }
    }
    function clearDiagnostics() {
        for (const doc of documents.all()) {
            connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
        }
    }
}
exports.createProjects = createProjects;
function createWorkspace(rootPath, ts, tsLocalized, options, documents, connection, lsConfigs, inferredCompilerOptions) {
    const rootTsConfigs = ts.sys.readDirectory(rootPath, rootTsConfigNames, undefined, ['**/*']);
    const projects = shared.createPathMap();
    let inferredProject;
    return {
        projects,
        getProject,
        getProjectAndTsConfig,
        getProjectByCreate,
        getInferredProject,
    };
    async function getProject(uri) {
        var _a;
        return (_a = (await getProjectAndTsConfig(uri))) === null || _a === void 0 ? void 0 : _a.project;
    }
    async function getProjectAndTsConfig(uri) {
        const tsconfig = await findMatchConfigs(uri);
        if (tsconfig) {
            const project = await getProjectByCreate(tsconfig);
            return {
                tsconfig: tsconfig,
                project,
            };
        }
    }
    function getInferredProject() {
        if (!inferredProject) {
            inferredProject = (0, project_1.createProject)(ts, options, rootPath, inferredCompilerOptions, tsLocalized, documents, connection, lsConfigs);
        }
        return inferredProject;
    }
    async function findMatchConfigs(uri) {
        var _a;
        const fileName = shared.uriToFsPath(uri);
        prepareClosestootParsedCommandLine();
        return (_a = await findDirectIncludeTsconfig()) !== null && _a !== void 0 ? _a : await findIndirectReferenceTsconfig();
        function prepareClosestootParsedCommandLine() {
            let matches = [];
            for (const rootTsConfig of rootTsConfigs) {
                if (shared.isFileInDir(shared.uriToFsPath(uri), path.dirname(rootTsConfig))) {
                    matches.push(rootTsConfig);
                }
            }
            matches = matches.sort(sortPaths);
            if (matches.length) {
                getParsedCommandLine(matches[0]);
            }
        }
        function findDirectIncludeTsconfig() {
            return findTsconfig(async (tsconfig) => {
                const parsedCommandLine = await getParsedCommandLine(tsconfig);
                const fileNames = new Set(parsedCommandLine.fileNames);
                return fileNames.has(fileName);
            });
        }
        function findIndirectReferenceTsconfig() {
            return findTsconfig(async (tsconfig) => {
                const project = await projects.fsPathGet(tsconfig);
                const ls = await (project === null || project === void 0 ? void 0 : project.getLanguageServiceDontCreate());
                const validDoc = ls === null || ls === void 0 ? void 0 : ls.__internal__.context.scriptTsLs.__internal__.getValidTextDocument(uri);
                return !!validDoc;
            });
        }
        async function findTsconfig(match) {
            const checked = new Set();
            for (const rootTsConfig of rootTsConfigs.sort(sortPaths)) {
                const project = await projects.fsPathGet(rootTsConfig);
                if (project) {
                    const chains = await getReferencesChains(project.getParsedCommandLine(), rootTsConfig, []);
                    for (const chain of chains) {
                        for (let i = chain.length - 1; i >= 0; i--) {
                            const tsconfig = chain[i];
                            if (checked.has(tsconfig))
                                continue;
                            checked.add(tsconfig);
                            if (await match(tsconfig)) {
                                return tsconfig;
                            }
                        }
                    }
                }
            }
        }
        async function getReferencesChains(parsedCommandLine, tsConfig, before) {
            var _a;
            if ((_a = parsedCommandLine.projectReferences) === null || _a === void 0 ? void 0 : _a.length) {
                const newChains = [];
                for (const projectReference of parsedCommandLine.projectReferences) {
                    const beforeIndex = before.indexOf(projectReference.path); // cycle
                    if (beforeIndex >= 0) {
                        newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
                    }
                    else {
                        const referenceParsedCommandLine = await getParsedCommandLine(projectReference.path);
                        for (const chain of await getReferencesChains(referenceParsedCommandLine, projectReference.path, [...before, tsConfig])) {
                            newChains.push(chain);
                        }
                    }
                }
                return newChains;
            }
            else {
                return [[...before, tsConfig]];
            }
        }
        async function getParsedCommandLine(tsConfig) {
            const project = await getProjectByCreate(tsConfig);
            return project.getParsedCommandLine();
        }
    }
    function getProjectByCreate(tsConfig) {
        let project = projects.fsPathGet(tsConfig);
        if (!project) {
            project = (0, project_1.createProject)(ts, options, path.dirname(tsConfig), tsConfig, tsLocalized, documents, connection, lsConfigs);
            projects.fsPathSet(tsConfig, project);
        }
        return project;
    }
}
function sortPaths(a, b) {
    const aLength = a.split('/').length;
    const bLength = b.split('/').length;
    if (aLength === bLength) {
        const aWeight = path.basename(a) === 'tsconfig.json' ? 1 : 0;
        const bWeight = path.basename(b) === 'tsconfig.json' ? 1 : 0;
        return bWeight - aWeight;
    }
    return bLength - aLength;
}
//# sourceMappingURL=projects.js.map