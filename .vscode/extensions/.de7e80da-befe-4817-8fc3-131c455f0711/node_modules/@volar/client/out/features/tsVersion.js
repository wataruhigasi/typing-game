"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCurrentTsPaths = exports.activate = void 0;
const vscode = require("vscode");
const shared = require("@volar/shared");
const splitEditors_1 = require("./splitEditors");
const defaultTsdk = 'node_modules/typescript/lib';
async function activate(context, clients) {
    const statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right);
    statusBar.command = 'volar.selectTypeScriptVersion';
    const subscription = vscode.commands.registerCommand('volar.selectTypeScriptVersion', async () => {
        var _a;
        const useWorkspaceTsdk = getCurrentTsPaths(context).isWorkspacePath;
        const workspaceTsPaths = getWorkspaceTsPaths();
        const workspaceTsVersion = workspaceTsPaths ? shared.getTypeScriptVersion(workspaceTsPaths.serverPath) : undefined;
        const vscodeTsPaths = getVscodeTsPaths();
        const vscodeTsVersion = shared.getTypeScriptVersion(vscodeTsPaths.serverPath);
        const tsdk = getTsdk();
        const defaultTsServer = shared.getWorkspaceTypescriptPath(defaultTsdk, ((_a = vscode.workspace.workspaceFolders) !== null && _a !== void 0 ? _a : []).map(folder => folder.uri.fsPath));
        const defaultTsVersion = defaultTsServer ? shared.getTypeScriptVersion(defaultTsServer) : undefined;
        const options = {};
        options[0] = {
            label: (!useWorkspaceTsdk ? '• ' : '') + "Use VS Code's Version",
            description: vscodeTsVersion,
        };
        if (tsdk) {
            options[1] = {
                label: (useWorkspaceTsdk ? '• ' : '') + 'Use Workspace Version',
                description: workspaceTsVersion !== null && workspaceTsVersion !== void 0 ? workspaceTsVersion : 'Could not load the TypeScript version at this path',
                detail: tsdk,
            };
        }
        if (tsdk !== defaultTsdk) {
            options[2] = {
                label: (useWorkspaceTsdk ? '• ' : '') + 'Use Workspace Version',
                description: defaultTsVersion !== null && defaultTsVersion !== void 0 ? defaultTsVersion : 'Could not load the TypeScript version at this path',
                detail: defaultTsdk,
            };
        }
        const select = await (0, splitEditors_1.userPick)(options);
        if (select === undefined)
            return; // cancle
        if (select === '2') {
            vscode.workspace.getConfiguration('typescript').update('tsdk', defaultTsdk);
        }
        const nowUseWorkspaceTsdk = select !== '0';
        if (nowUseWorkspaceTsdk !== isUseWorkspaceTsdk(context)) {
            context.workspaceState.update('typescript.useWorkspaceTsdk', nowUseWorkspaceTsdk);
            reloadServers();
        }
        updateStatusBar();
    });
    context.subscriptions.push(subscription);
    let tsdk = getTsdk();
    vscode.workspace.onDidChangeConfiguration(() => {
        const newTsdk = getTsdk();
        if (newTsdk !== tsdk) {
            tsdk = newTsdk;
            if (isUseWorkspaceTsdk(context)) {
                reloadServers();
            }
        }
    });
    updateStatusBar();
    vscode.window.onDidChangeActiveTextEditor(updateStatusBar, undefined, context.subscriptions);
    function updateStatusBar() {
        var _a;
        if (((_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document.languageId) !== 'vue') {
            statusBar.hide();
        }
        else {
            const tsPaths = getCurrentTsPaths(context);
            const tsVersion = shared.getTypeScriptVersion(tsPaths.serverPath);
            statusBar.text = 'TS ' + tsVersion;
            statusBar.show();
        }
    }
    async function reloadServers() {
        const tsPaths = getCurrentTsPaths(context);
        for (const client of clients) {
            const newInitOptions = {
                ...client.clientOptions.initializationOptions,
                typescript: tsPaths,
            };
            client.clientOptions.initializationOptions = newInitOptions;
        }
        vscode.commands.executeCommand('volar.action.restartServer');
    }
}
exports.activate = activate;
function getCurrentTsPaths(context) {
    if (isUseWorkspaceTsdk(context)) {
        const workspaceTsPaths = getWorkspaceTsPaths(true);
        if (workspaceTsPaths) {
            return { ...workspaceTsPaths, isWorkspacePath: true };
        }
    }
    return { ...getVscodeTsPaths(), isWorkspacePath: false };
}
exports.getCurrentTsPaths = getCurrentTsPaths;
function getWorkspaceTsPaths(useDefault = false) {
    var _a;
    let tsdk = getTsdk();
    if (!tsdk && useDefault) {
        tsdk = defaultTsdk;
    }
    if (tsdk) {
        const fsPaths = ((_a = vscode.workspace.workspaceFolders) !== null && _a !== void 0 ? _a : []).map(folder => folder.uri.fsPath);
        const tsPath = shared.getWorkspaceTypescriptPath(tsdk, fsPaths);
        if (tsPath) {
            return {
                serverPath: tsPath,
                localizedPath: shared.getWorkspaceTypescriptLocalizedPath(tsdk, vscode.env.language, fsPaths),
            };
        }
    }
}
function getVscodeTsPaths() {
    return {
        serverPath: shared.getVscodeTypescriptPath(vscode.env.appRoot),
        localizedPath: shared.getVscodeTypescriptLocalizedPath(vscode.env.appRoot, vscode.env.language),
    };
}
function getTsdk() {
    const tsConfigs = vscode.workspace.getConfiguration('typescript');
    const tsdk = tsConfigs.get('tsdk');
    return tsdk;
}
function isUseWorkspaceTsdk(context) {
    return context.workspaceState.get('typescript.useWorkspaceTsdk', false);
}
//# sourceMappingURL=tsVersion.js.map